### This file was autogenerated by Nexus 0.11.4
### Do not make changes to this file directly


type AggregatePlace {
  count: Int!
}

type AggregateThing {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar Long

type Mutation {
  createPlace(data: PlaceCreateInput!): Place!
  createThing(data: ThingCreateInput!): Thing!
  deleteManyPlaces(where: PlaceWhereInput): BatchPayload!
  deleteManyThings(where: ThingWhereInput): BatchPayload!
  deletePlace(where: PlaceWhereUniqueInput!): Place
  deleteThing(where: ThingWhereUniqueInput!): Thing
  updateManyPlaces(data: PlaceUpdateManyMutationInput!, where: PlaceWhereInput): BatchPayload!
  updateManyThings(data: ThingUpdateManyMutationInput!, where: ThingWhereInput): BatchPayload!
  updatePlace(data: PlaceUpdateInput!, where: PlaceWhereUniqueInput!): Place
  updateThing(data: ThingUpdateInput!, where: ThingWhereUniqueInput!): Thing
  upsertPlace(create: PlaceCreateInput!, update: PlaceUpdateInput!, where: PlaceWhereUniqueInput!): Place!
  upsertThing(create: ThingCreateInput!, update: ThingUpdateInput!, where: ThingWhereUniqueInput!): Thing!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Place {
  hasSubplaces: Boolean!
  id: ID!
  name: String!
  subPlaces(after: String, before: String, first: Int, last: Int, orderBy: PlaceOrderByInput, skip: Int, where: PlaceWhereInput): [Place!]
  things(after: String, before: String, first: Int, last: Int, orderBy: ThingOrderByInput, skip: Int, where: ThingWhereInput): [Thing!]
}

type PlaceConnection {
  aggregate: AggregatePlace!
  edges: [PlaceEdge!]!
  pageInfo: PageInfo!
}

input PlaceCreateInput {
  name: String!
  subPlaces: PlaceCreateManyInput
  things: ThingCreateManyWithoutPlaceInput
}

input PlaceCreateManyInput {
  connect: [PlaceWhereUniqueInput!]
  create: [PlaceCreateInput!]
}

input PlaceCreateOneWithoutThingsInput {
  connect: PlaceWhereUniqueInput
  create: PlaceCreateWithoutThingsInput
}

input PlaceCreateWithoutThingsInput {
  name: String!
  subPlaces: PlaceCreateManyInput
}

type PlaceEdge {
  cursor: String!
  node: Place!
}

enum PlaceOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input PlaceScalarWhereInput {
  AND: [PlaceScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [PlaceScalarWhereInput!]
  OR: [PlaceScalarWhereInput!]
}

input PlaceUpdateDataInput {
  name: String
  subPlaces: PlaceUpdateManyInput
  things: ThingUpdateManyWithoutPlaceInput
}

input PlaceUpdateInput {
  name: String
  subPlaces: PlaceUpdateManyInput
  things: ThingUpdateManyWithoutPlaceInput
}

input PlaceUpdateManyDataInput {
  name: String
}

input PlaceUpdateManyInput {
  connect: [PlaceWhereUniqueInput!]
  create: [PlaceCreateInput!]
  delete: [PlaceWhereUniqueInput!]
  deleteMany: [PlaceScalarWhereInput!]
  disconnect: [PlaceWhereUniqueInput!]
  set: [PlaceWhereUniqueInput!]
  update: [PlaceUpdateWithWhereUniqueNestedInput!]
  updateMany: [PlaceUpdateManyWithWhereNestedInput!]
  upsert: [PlaceUpsertWithWhereUniqueNestedInput!]
}

input PlaceUpdateManyMutationInput {
  name: String
}

input PlaceUpdateManyWithWhereNestedInput {
  data: PlaceUpdateManyDataInput!
  where: PlaceScalarWhereInput!
}

input PlaceUpdateOneRequiredWithoutThingsInput {
  connect: PlaceWhereUniqueInput
  create: PlaceCreateWithoutThingsInput
  update: PlaceUpdateWithoutThingsDataInput
  upsert: PlaceUpsertWithoutThingsInput
}

input PlaceUpdateWithoutThingsDataInput {
  name: String
  subPlaces: PlaceUpdateManyInput
}

input PlaceUpdateWithWhereUniqueNestedInput {
  data: PlaceUpdateDataInput!
  where: PlaceWhereUniqueInput!
}

input PlaceUpsertWithoutThingsInput {
  create: PlaceCreateWithoutThingsInput!
  update: PlaceUpdateWithoutThingsDataInput!
}

input PlaceUpsertWithWhereUniqueNestedInput {
  create: PlaceCreateInput!
  update: PlaceUpdateDataInput!
  where: PlaceWhereUniqueInput!
}

input PlaceWhereInput {
  AND: [PlaceWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [PlaceWhereInput!]
  OR: [PlaceWhereInput!]
  subPlaces_every: PlaceWhereInput
  subPlaces_none: PlaceWhereInput
  subPlaces_some: PlaceWhereInput
  things_every: ThingWhereInput
  things_none: ThingWhereInput
  things_some: ThingWhereInput
}

input PlaceWhereUniqueInput {
  id: ID
}

type Query {
  place(where: PlaceWhereUniqueInput!): Place
  places(after: String, before: String, first: Int, last: Int, orderBy: PlaceOrderByInput, skip: Int, where: PlaceWhereInput): [Place!]!
  placesConnection(after: String, before: String, first: Int, last: Int, orderBy: PlaceOrderByInput, skip: Int, where: PlaceWhereInput): PlaceConnection!
  thing(where: ThingWhereUniqueInput!): Thing
  things(after: String, before: String, first: Int, last: Int, orderBy: ThingOrderByInput, skip: Int, where: ThingWhereInput): [Thing!]!
  thingsConnection(after: String, before: String, first: Int, last: Int, orderBy: ThingOrderByInput, skip: Int, where: ThingWhereInput): ThingConnection!
}

type Thing {
  id: ID!
  name: String!
  place: Place!
}

type ThingConnection {
  aggregate: AggregateThing!
  edges: [ThingEdge!]!
  pageInfo: PageInfo!
}

input ThingCreateInput {
  name: String!
  place: PlaceCreateOneWithoutThingsInput!
}

input ThingCreateManyWithoutPlaceInput {
  connect: [ThingWhereUniqueInput!]
  create: [ThingCreateWithoutPlaceInput!]
}

input ThingCreateWithoutPlaceInput {
  name: String!
}

type ThingEdge {
  cursor: String!
  node: Thing!
}

enum ThingOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ThingScalarWhereInput {
  AND: [ThingScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ThingScalarWhereInput!]
  OR: [ThingScalarWhereInput!]
}

input ThingUpdateInput {
  name: String
  place: PlaceUpdateOneRequiredWithoutThingsInput
}

input ThingUpdateManyDataInput {
  name: String
}

input ThingUpdateManyMutationInput {
  name: String
}

input ThingUpdateManyWithoutPlaceInput {
  connect: [ThingWhereUniqueInput!]
  create: [ThingCreateWithoutPlaceInput!]
  delete: [ThingWhereUniqueInput!]
  deleteMany: [ThingScalarWhereInput!]
  disconnect: [ThingWhereUniqueInput!]
  set: [ThingWhereUniqueInput!]
  update: [ThingUpdateWithWhereUniqueWithoutPlaceInput!]
  updateMany: [ThingUpdateManyWithWhereNestedInput!]
  upsert: [ThingUpsertWithWhereUniqueWithoutPlaceInput!]
}

input ThingUpdateManyWithWhereNestedInput {
  data: ThingUpdateManyDataInput!
  where: ThingScalarWhereInput!
}

input ThingUpdateWithoutPlaceDataInput {
  name: String
}

input ThingUpdateWithWhereUniqueWithoutPlaceInput {
  data: ThingUpdateWithoutPlaceDataInput!
  where: ThingWhereUniqueInput!
}

input ThingUpsertWithWhereUniqueWithoutPlaceInput {
  create: ThingCreateWithoutPlaceInput!
  update: ThingUpdateWithoutPlaceDataInput!
  where: ThingWhereUniqueInput!
}

input ThingWhereInput {
  AND: [ThingWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ThingWhereInput!]
  OR: [ThingWhereInput!]
  place: PlaceWhereInput
}

input ThingWhereUniqueInput {
  id: ID
}
