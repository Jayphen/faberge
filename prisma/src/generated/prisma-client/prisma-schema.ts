// Code generated by Prisma (prisma@1.29.0-beta.9). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregatePlace {
  count: Int!
}

type AggregateThing {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar Long

type Mutation {
  createPlace(data: PlaceCreateInput!): Place!
  updatePlace(data: PlaceUpdateInput!, where: PlaceWhereUniqueInput!): Place
  updateManyPlaces(data: PlaceUpdateManyMutationInput!, where: PlaceWhereInput): BatchPayload!
  upsertPlace(where: PlaceWhereUniqueInput!, create: PlaceCreateInput!, update: PlaceUpdateInput!): Place!
  deletePlace(where: PlaceWhereUniqueInput!): Place
  deleteManyPlaces(where: PlaceWhereInput): BatchPayload!
  createThing(data: ThingCreateInput!): Thing!
  updateThing(data: ThingUpdateInput!, where: ThingWhereUniqueInput!): Thing
  updateManyThings(data: ThingUpdateManyMutationInput!, where: ThingWhereInput): BatchPayload!
  upsertThing(where: ThingWhereUniqueInput!, create: ThingCreateInput!, update: ThingUpdateInput!): Thing!
  deleteThing(where: ThingWhereUniqueInput!): Thing
  deleteManyThings(where: ThingWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Place {
  id: ID!
  name: String!
  things(where: ThingWhereInput, orderBy: ThingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Thing!]
  subPlaces(where: PlaceWhereInput, orderBy: PlaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Place!]
  depth: Int!
  parentPlace: Place
}

type PlaceConnection {
  pageInfo: PageInfo!
  edges: [PlaceEdge]!
  aggregate: AggregatePlace!
}

input PlaceCreateInput {
  name: String!
  things: ThingCreateManyWithoutPlaceInput
  subPlaces: PlaceCreateManyWithoutParentPlaceInput
  depth: Int!
  parentPlace: PlaceCreateOneWithoutSubPlacesInput
}

input PlaceCreateManyWithoutParentPlaceInput {
  create: [PlaceCreateWithoutParentPlaceInput!]
  connect: [PlaceWhereUniqueInput!]
}

input PlaceCreateOneWithoutSubPlacesInput {
  create: PlaceCreateWithoutSubPlacesInput
  connect: PlaceWhereUniqueInput
}

input PlaceCreateOneWithoutThingsInput {
  create: PlaceCreateWithoutThingsInput
  connect: PlaceWhereUniqueInput
}

input PlaceCreateWithoutParentPlaceInput {
  name: String!
  things: ThingCreateManyWithoutPlaceInput
  subPlaces: PlaceCreateManyWithoutParentPlaceInput
  depth: Int!
}

input PlaceCreateWithoutSubPlacesInput {
  name: String!
  things: ThingCreateManyWithoutPlaceInput
  depth: Int!
  parentPlace: PlaceCreateOneWithoutSubPlacesInput
}

input PlaceCreateWithoutThingsInput {
  name: String!
  subPlaces: PlaceCreateManyWithoutParentPlaceInput
  depth: Int!
  parentPlace: PlaceCreateOneWithoutSubPlacesInput
}

type PlaceEdge {
  node: Place!
  cursor: String!
}

enum PlaceOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  depth_ASC
  depth_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PlacePreviousValues {
  id: ID!
  name: String!
  depth: Int!
}

input PlaceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  depth: Int
  depth_not: Int
  depth_in: [Int!]
  depth_not_in: [Int!]
  depth_lt: Int
  depth_lte: Int
  depth_gt: Int
  depth_gte: Int
  AND: [PlaceScalarWhereInput!]
  OR: [PlaceScalarWhereInput!]
  NOT: [PlaceScalarWhereInput!]
}

type PlaceSubscriptionPayload {
  mutation: MutationType!
  node: Place
  updatedFields: [String!]
  previousValues: PlacePreviousValues
}

input PlaceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlaceWhereInput
  AND: [PlaceSubscriptionWhereInput!]
  OR: [PlaceSubscriptionWhereInput!]
  NOT: [PlaceSubscriptionWhereInput!]
}

input PlaceUpdateInput {
  name: String
  things: ThingUpdateManyWithoutPlaceInput
  subPlaces: PlaceUpdateManyWithoutParentPlaceInput
  depth: Int
  parentPlace: PlaceUpdateOneWithoutSubPlacesInput
}

input PlaceUpdateManyDataInput {
  name: String
  depth: Int
}

input PlaceUpdateManyMutationInput {
  name: String
  depth: Int
}

input PlaceUpdateManyWithoutParentPlaceInput {
  create: [PlaceCreateWithoutParentPlaceInput!]
  delete: [PlaceWhereUniqueInput!]
  connect: [PlaceWhereUniqueInput!]
  set: [PlaceWhereUniqueInput!]
  disconnect: [PlaceWhereUniqueInput!]
  update: [PlaceUpdateWithWhereUniqueWithoutParentPlaceInput!]
  upsert: [PlaceUpsertWithWhereUniqueWithoutParentPlaceInput!]
  deleteMany: [PlaceScalarWhereInput!]
  updateMany: [PlaceUpdateManyWithWhereNestedInput!]
}

input PlaceUpdateManyWithWhereNestedInput {
  where: PlaceScalarWhereInput!
  data: PlaceUpdateManyDataInput!
}

input PlaceUpdateOneRequiredWithoutThingsInput {
  create: PlaceCreateWithoutThingsInput
  update: PlaceUpdateWithoutThingsDataInput
  upsert: PlaceUpsertWithoutThingsInput
  connect: PlaceWhereUniqueInput
}

input PlaceUpdateOneWithoutSubPlacesInput {
  create: PlaceCreateWithoutSubPlacesInput
  update: PlaceUpdateWithoutSubPlacesDataInput
  upsert: PlaceUpsertWithoutSubPlacesInput
  delete: Boolean
  disconnect: Boolean
  connect: PlaceWhereUniqueInput
}

input PlaceUpdateWithoutParentPlaceDataInput {
  name: String
  things: ThingUpdateManyWithoutPlaceInput
  subPlaces: PlaceUpdateManyWithoutParentPlaceInput
  depth: Int
}

input PlaceUpdateWithoutSubPlacesDataInput {
  name: String
  things: ThingUpdateManyWithoutPlaceInput
  depth: Int
  parentPlace: PlaceUpdateOneWithoutSubPlacesInput
}

input PlaceUpdateWithoutThingsDataInput {
  name: String
  subPlaces: PlaceUpdateManyWithoutParentPlaceInput
  depth: Int
  parentPlace: PlaceUpdateOneWithoutSubPlacesInput
}

input PlaceUpdateWithWhereUniqueWithoutParentPlaceInput {
  where: PlaceWhereUniqueInput!
  data: PlaceUpdateWithoutParentPlaceDataInput!
}

input PlaceUpsertWithoutSubPlacesInput {
  update: PlaceUpdateWithoutSubPlacesDataInput!
  create: PlaceCreateWithoutSubPlacesInput!
}

input PlaceUpsertWithoutThingsInput {
  update: PlaceUpdateWithoutThingsDataInput!
  create: PlaceCreateWithoutThingsInput!
}

input PlaceUpsertWithWhereUniqueWithoutParentPlaceInput {
  where: PlaceWhereUniqueInput!
  update: PlaceUpdateWithoutParentPlaceDataInput!
  create: PlaceCreateWithoutParentPlaceInput!
}

input PlaceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  things_every: ThingWhereInput
  things_some: ThingWhereInput
  things_none: ThingWhereInput
  subPlaces_every: PlaceWhereInput
  subPlaces_some: PlaceWhereInput
  subPlaces_none: PlaceWhereInput
  depth: Int
  depth_not: Int
  depth_in: [Int!]
  depth_not_in: [Int!]
  depth_lt: Int
  depth_lte: Int
  depth_gt: Int
  depth_gte: Int
  parentPlace: PlaceWhereInput
  AND: [PlaceWhereInput!]
  OR: [PlaceWhereInput!]
  NOT: [PlaceWhereInput!]
}

input PlaceWhereUniqueInput {
  id: ID
}

type Query {
  place(where: PlaceWhereUniqueInput!): Place
  places(where: PlaceWhereInput, orderBy: PlaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Place]!
  placesConnection(where: PlaceWhereInput, orderBy: PlaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlaceConnection!
  thing(where: ThingWhereUniqueInput!): Thing
  things(where: ThingWhereInput, orderBy: ThingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Thing]!
  thingsConnection(where: ThingWhereInput, orderBy: ThingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ThingConnection!
  node(id: ID!): Node
}

type Subscription {
  place(where: PlaceSubscriptionWhereInput): PlaceSubscriptionPayload
  thing(where: ThingSubscriptionWhereInput): ThingSubscriptionPayload
}

type Thing {
  id: ID!
  name: String!
  place: Place!
}

type ThingConnection {
  pageInfo: PageInfo!
  edges: [ThingEdge]!
  aggregate: AggregateThing!
}

input ThingCreateInput {
  name: String!
  place: PlaceCreateOneWithoutThingsInput!
}

input ThingCreateManyWithoutPlaceInput {
  create: [ThingCreateWithoutPlaceInput!]
  connect: [ThingWhereUniqueInput!]
}

input ThingCreateWithoutPlaceInput {
  name: String!
}

type ThingEdge {
  node: Thing!
  cursor: String!
}

enum ThingOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ThingPreviousValues {
  id: ID!
  name: String!
}

input ThingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ThingScalarWhereInput!]
  OR: [ThingScalarWhereInput!]
  NOT: [ThingScalarWhereInput!]
}

type ThingSubscriptionPayload {
  mutation: MutationType!
  node: Thing
  updatedFields: [String!]
  previousValues: ThingPreviousValues
}

input ThingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ThingWhereInput
  AND: [ThingSubscriptionWhereInput!]
  OR: [ThingSubscriptionWhereInput!]
  NOT: [ThingSubscriptionWhereInput!]
}

input ThingUpdateInput {
  name: String
  place: PlaceUpdateOneRequiredWithoutThingsInput
}

input ThingUpdateManyDataInput {
  name: String
}

input ThingUpdateManyMutationInput {
  name: String
}

input ThingUpdateManyWithoutPlaceInput {
  create: [ThingCreateWithoutPlaceInput!]
  delete: [ThingWhereUniqueInput!]
  connect: [ThingWhereUniqueInput!]
  set: [ThingWhereUniqueInput!]
  disconnect: [ThingWhereUniqueInput!]
  update: [ThingUpdateWithWhereUniqueWithoutPlaceInput!]
  upsert: [ThingUpsertWithWhereUniqueWithoutPlaceInput!]
  deleteMany: [ThingScalarWhereInput!]
  updateMany: [ThingUpdateManyWithWhereNestedInput!]
}

input ThingUpdateManyWithWhereNestedInput {
  where: ThingScalarWhereInput!
  data: ThingUpdateManyDataInput!
}

input ThingUpdateWithoutPlaceDataInput {
  name: String
}

input ThingUpdateWithWhereUniqueWithoutPlaceInput {
  where: ThingWhereUniqueInput!
  data: ThingUpdateWithoutPlaceDataInput!
}

input ThingUpsertWithWhereUniqueWithoutPlaceInput {
  where: ThingWhereUniqueInput!
  update: ThingUpdateWithoutPlaceDataInput!
  create: ThingCreateWithoutPlaceInput!
}

input ThingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  place: PlaceWhereInput
  AND: [ThingWhereInput!]
  OR: [ThingWhereInput!]
  NOT: [ThingWhereInput!]
}

input ThingWhereUniqueInput {
  id: ID
}
`